<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Mapa Embebido</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    iframe {
      border: none;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <iframe src="https://geovisor.smt-onic.com/catalogue/#/map/84"></iframe>
</body>
</html>



def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)

        # === Viviendas (coordenadas) ===
        with connection.cursor() as cursor:
            cursor.execute("""
                SELECT DISTINCT ON (su.id)
                    su.id AS vivienda_id,
                    (sa.data->'value'->>'latitude')::numeric AS latitud,
                    (sa.data->'value'->>'longitude')::numeric AS longitud,
                    sa.created_at
                FROM survey_answer sa
                JOIN survey_surveyuser su ON sa.survey_user_id = su.id
                WHERE sa.survey_question_id = 55
                  AND jsonb_typeof(sa.data->'value') = 'object'
                  AND sa.data->'value'->>'latitude' IS NOT NULL
                  AND sa.data->'value'->>'longitude' IS NOT NULL
                ORDER BY su.id, sa.created_at DESC;
            """)
            cols = [col[0] for col in cursor.description]
            viviendas = [dict(zip(cols, row)) for row in cursor.fetchall()]

        # === Sectores (con coordenadas) ===
        with connection.cursor() as cursor:
            cursor.execute("""
                WITH coords AS (
                  SELECT DISTINCT ON (su.id)
                      su.id AS vivienda_id,
                      (sa.data->'value'->>'latitude')::numeric  AS latitud,
                      (sa.data->'value'->>'longitude')::numeric AS longitud,
                      sa.created_at
                  FROM survey_answer sa
                  JOIN survey_surveyuser su ON sa.survey_user_id = su.id
                  WHERE sa.survey_question_id = 55
                    AND jsonb_typeof(sa.data->'value') = 'object'
                    AND sa.data->'value'->>'latitude' IS NOT NULL
                    AND sa.data->'value'->>'longitude' IS NOT NULL
                  ORDER BY su.id, sa.created_at DESC
                ),
                sector_ult AS (
                  SELECT DISTINCT ON (su.id)
                      su.id AS vivienda_id,
                      NULLIF(
                        CASE
                          WHEN jsonb_typeof(sa.data->'value') = 'object' THEN sa.data->'value'->>'label'
                          ELSE sa.data->>'value'
                        END,
                      '') AS sector,
                      sa.created_at
                  FROM survey_answer sa
                  JOIN survey_surveyuser su ON sa.survey_user_id = su.id
                  WHERE sa.survey_question_id IN (477, 863)
                  ORDER BY su.id, sa.created_at DESC
                )
                SELECT
                  c.vivienda_id,
                  c.latitud,
                  c.longitud,
                  COALESCE(s.sector, 'SIN SECTOR') AS sector
                FROM coords c
                LEFT JOIN sector_ult s USING (vivienda_id);
            """)
            cols = [col[0] for col in cursor.description]
            sectores = [dict(zip(cols, row)) for row in cursor.fetchall()]

        # === Personas (con coordenadas) ===
        with connection.cursor() as cursor:
            cursor.execute("""
                WITH coords AS (
                  SELECT DISTINCT ON (su.id)
                      su.id AS vivienda_id,
                      (sa.data->'value'->>'latitude')::numeric  AS latitud,
                      (sa.data->'value'->>'longitude')::numeric AS longitud,
                      sa.created_at
                  FROM survey_answer sa
                  JOIN survey_surveyuser su ON sa.survey_user_id = su.id
                  WHERE sa.survey_question_id = 55
                    AND jsonb_typeof(sa.data->'value') = 'object'
                    AND sa.data->'value'->>'latitude' IS NOT NULL
                    AND sa.data->'value'->>'longitude' IS NOT NULL
                  ORDER BY su.id, sa.created_at DESC
                ),
                personas_ult AS (
                  SELECT DISTINCT ON (su.id)
                      su.id AS vivienda_id,
                      CASE
                        WHEN sa.data ? 'value' AND (sa.data->>'value') ~ '^[0-9]+$'
                          THEN (sa.data->>'value')::int
                        WHEN jsonb_typeof(sa.data->'value') = 'object'
                             AND (sa.data->'value'->>'cantidad') ~ '^[0-9]+$'
                          THEN (sa.data->'value'->>'cantidad')::int
                        ELSE NULL
                      END AS total_personas,
                      sa.created_at
                  FROM survey_answer sa
                  JOIN survey_surveyuser su ON sa.survey_user_id = su.id
                  WHERE sa.survey_question_id = 100  -- id real de poblaci√≥n
                  ORDER BY su.id, sa.created_at DESC
                )
                SELECT
                  c.vivienda_id,
                  c.latitud,
                  c.longitud,
                  COALESCE(p.total_personas, 0) AS total_personas
                FROM coords c
                LEFT JOIN personas_ult p USING (vivienda_id);
            """)
            cols = [col[0] for col in cursor.description]
            personas = [dict(zip(cols, row)) for row in cursor.fetchall()]

        # === Centro del mapa ===
        if viviendas:
            latitudes = [v["latitud"] for v in viviendas if v["latitud"]]
            longitudes = [v["longitud"] for v in viviendas if v["longitud"]]
            lat_centro = sum(latitudes) / len(latitudes)
            lon_centro = sum(longitudes) / len(longitudes)
        else:
            lat_centro, lon_centro = 4.65, -74.1

        # === Crear mapa ===
        m = folium.Map(location=[lat_centro, lon_centro], zoom_start=12, tiles=None, attributionControl = False)

        # Capas base
        mapas_base = [
            ("Esri World Imagery",
             "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
             "Tiles ¬© Esri ‚Äî Source: Esri, Earthstar Geographics, GeoEye"),
            ("OpenStreetMap",
             "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
             "¬© OpenStreetMap contributors"),
        ]
        for nombre, url, attr in mapas_base:
            folium.TileLayer(tiles=url, name=nombre, attr=attr, overlay=False).add_to(m)

        # === Capa viviendas ===
        capa_viviendas = folium.FeatureGroup(name="Viviendas", show=True)
        cluster = MarkerCluster().add_to(capa_viviendas)
        for v in viviendas:
            if not v["latitud"] or not v["longitud"]:
                continue
            folium.CircleMarker(
                [v["latitud"], v["longitud"]],
                radius=5,
                color="blue",
                fill=True,
                fill_color="blue",
                fill_opacity=0.6,
                popup=f"Vivienda {v['vivienda_id']}<br>{v['created_at']}"
            ).add_to(cluster)
        capa_viviendas.add_to(m)

        # === Capa sectores ===
        capa_sectores = folium.FeatureGroup(name="Sectores", show=False)
        for s in sectores:
            if not s["latitud"] or not s["longitud"]:
                continue
            folium.Marker(
                [s["latitud"], s["longitud"]],
                icon=folium.Icon(color="purple", icon="home"),
                popup=f"Vivienda {s['vivienda_id']}<br>Sector: {s['sector']}"
            ).add_to(capa_sectores)
        capa_sectores.add_to(m)

        # === Capa poblaci√≥n ===
        capa_personas = folium.FeatureGroup(name="Poblaci√≥n", show=False)
        for p in personas:
            if not p["latitud"] or not p["longitud"]:
                continue
            folium.CircleMarker(
                [p["latitud"], p["longitud"]],
                radius=3 + (p["total_personas"] or 0),  # radio proporcional
                color="red",
                fill=True,
                fill_color="red",
                fill_opacity=0.6,
                popup=f"Vivienda {p['vivienda_id']}<br>Personas: {p['total_personas']}"
            ).add_to(capa_personas)
        capa_personas.add_to(m)

        # === Heatmap ===
        heat_data = [[p["latitud"], p["longitud"], p["total_personas"]] for p in personas if p["latitud"] and p["longitud"]]
        if heat_data:
            HeatMap(heat_data, radius=12, blur=8, min_opacity=0.4, name="Densidad poblacional").add_to(m)

        # Control de capas
        folium.LayerControl(collapsed=False).add_to(m)

        context["mapa"] = m._repr_html_()
        return context

def total_encuestas_realtime(request):
    query = """
        SELECT COUNT(DISTINCT sa.survey_user_id) AS total_encuestas
        FROM survey_answer sa
        INNER JOIN survey_surveyuser su 
            ON sa.survey_user_id = su.id
        WHERE su.survey_id IN (18, 30, 31)                -- solo encuestas 18 y 30
          AND sa.created_at::date = CURRENT_DATE;     -- solo encuestas de hoy
    """
    
    with connection.cursor() as cursor:
        cursor.execute(query)
        row = cursor.fetchone()
    
    total = row[0] if row else 0
    
    return JsonResponse({
        "total_encuestas": total
    })

def encuestas_sector_477(request):
    query = """
       SELECT
            COALESCE(sa.data->>'value', 'SIN SECTOR') AS sector,
            COUNT(DISTINCT sa.survey_user_id) AS total_encuestas
        FROM survey_answer sa
        WHERE sa.survey_question_id IN (477, 863)   -- sector puede venir de cualquiera
        AND sa.created_at::date = CURRENT_DATE
        GROUP BY ROLLUP (sa.data->>'value')
        ORDER BY sector;
    """
    
    with connection.cursor() as cursor:
        cursor.execute(query)
        rows = cursor.fetchall()
    
    # Convertimos a lista de dicts [{sector: "1", total: 38}, ...]
    sectores = [{"sector": row[0], "total": row[1]} for row in rows]

    return JsonResponse({
        "pregunta_id": 477,
        "sectores": sectores
    })


def encuestas_viviendas(request):
    """
    Retorna cu√°ntas encuestas tienen la pregunta con id = 122 (viviendas)
    para las encuestas con survey_id 18 y 30.
    """
    query = """
        SELECT COUNT(DISTINCT sa.data->>'value') AS total_viviendas
            FROM survey_answer sa
            JOIN survey_surveyuser su 
            ON sa.survey_user_id = su.id
            WHERE su.survey_id IN (18, 30)
            AND sa.survey_question_id IN (614, 615, 616)
            AND sa.created_at::date = CURRENT_DATE;
    """

    with connection.cursor() as cursor:
        cursor.execute(query)
        row = cursor.fetchone()

    total_viviendas = row[0] if row else 0

    return JsonResponse({
        "pregunta_id": 122,
        "total_viviendas": total_viviendas
    })
    
def total_personas_realtime(request):
    query = """
        WITH latest AS (
          SELECT DISTINCT ON (sa.survey_user_id)
                 sa.survey_user_id,
                 TRIM(sa.data->>'value') AS v
          FROM survey_answer sa
          JOIN survey_surveyuser su ON sa.survey_user_id = su.id
          WHERE su.survey_id IN (18, 30)
            AND sa.survey_question_id = 600
            AND sa.created_at::date = CURRENT_DATE
          ORDER BY sa.survey_user_id, sa.created_at DESC
        )
        SELECT COALESCE(SUM((NULLIF(regexp_replace(v, '\\D', '', 'g'), ''))::int), 0) AS total_personas
        FROM latest;
    """
    with connection.cursor() as cursor:
        cursor.execute(query)
        row = cursor.fetchone()

    total = row[0] if row and row[0] is not None else 0
    return JsonResponse({"total_personas": total})

def encuestas_por_usuario_hoy(request):
    """
    Devuelve encuestas agrupadas por usuario para la fecha actual.
    """
    query = """
        SELECT 
            u.id AS usuario_id,
            u.username AS usuario_login,
            (u.first_name || ' ' || u.last_name) AS usuario_nombre,
            COUNT(DISTINCT su.id) AS total_encuestas_hoy
        FROM survey_surveyuser su
        JOIN auth_user u 
            ON su.user_id = u.id
        JOIN survey_answer sa 
            ON sa.survey_user_id = su.id
        WHERE su.survey_id IN (18, 30)
          AND sa.created_at::date = CURRENT_DATE
        GROUP BY u.id, u.username, u.first_name, u.last_name
        ORDER BY total_encuestas_hoy DESC;
    """
    with connection.cursor() as cursor:
        cursor.execute(query)
        columns = [col[0] for col in cursor.description]
        rows = cursor.fetchall()

    data = [dict(zip(columns, row)) for row in rows]
    return JsonResponse({"encuestas": data})





    # Consolidado
// === MAPA ===
  let map = L.map('map', { attributionControl: false });
  L.tileLayer(
    "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    { maxZoom: 20 }
  ).addTo(map);

  // Atribuci√≥n personalizada
  L.control.attribution({position:'bottomright'})
    .addAttribution("¬© Dashboard SMT-ONIC")
    .addTo(map);

  // Capas
  let layerTotal = L.layerGroup().addTo(map);
  let layerViviendas = L.layerGroup().addTo(map);
  let layerSectores = L.layerGroup().addTo(map);

  L.control.layers(null, {
    "Total Encuestas": layerTotal,
    "Viviendas": layerViviendas,
    "Sectores": layerSectores
  }, {collapsed:false}).addTo(map);

  // Icono especial para viviendas
  const houseIcon = L.divIcon({
    html: "üè†",
    className: "text-2xl",
    iconSize: [24,24],
    iconAnchor: [12,12]
  });

  // ‚ö° Para evitar zoom en cada refresh
  let firstFit = true;
  let lastMarkers = [];

  function updateUI(payload) {
    // === KPIs ===
    document.getElementById('kpi-total').textContent = (payload.kpis.total_encuestas ?? 0).toLocaleString();
    document.getElementById('kpi-viviendas').textContent = (payload.kpis.total_viviendas ?? 0).toLocaleString();
    document.getElementById('kpi-sectores').textContent = (payload.kpis.total_sectores ?? 0).toLocaleString();

    // === Gr√°fica censistas ===
    const censistas = payload.censistas || [];
    Plotly.react('chart-censistas', [{
      x: censistas.map(r => String(r.convencion)),
      y: censistas.map(r => r.total_encuestas),
      type: 'bar',
      text: censistas.map(r => r.nombre_completo),
      hoverinfo: 'text+y'
    }], {
      paper_bgcolor:'#111827',
      plot_bgcolor:'#111827',
      font:{color:'#e5e7eb'},
      xaxis:{title:"Censista (ID)", type:"category"},
      yaxis:{title:"Encuestas"}
    }, {displayModeBar:false});

    // === Gr√°fica sectores ===
    const sectores = payload.sectores || [];
    Plotly.react('chart-sectores', [{
      labels: sectores.map(r => r.sector),
      values: sectores.map(r => r.total),
      type: 'pie',
      hole:.45
    }], {
      paper_bgcolor:'#111827',
      font:{color:'#e5e7eb'}
    }, {displayModeBar:false});

    // === Tabla convenciones ===
    const tbody = document.getElementById('tabla-convenciones');
    tbody.innerHTML = '';
    (payload.convenciones || []).forEach(row => {
      tbody.innerHTML += `
        <tr class="border-b border-gray-700">
          <td class="px-4 py-2">${row.convencion}</td>
          <td class="px-4 py-2">${row.nombre_completo}</td>
          <td class="px-4 py-2">${row.total_encuestas}</td>
        </tr>`;
    });

    // === MAPA ===
    layerTotal.clearLayers();
    layerViviendas.clearLayers();
    layerSectores.clearLayers();
    let markers = [];

    // Total encuestas
    (payload.geo || []).forEach(r => {
      if(r.lat && r.lng){
        let m = L.circleMarker([r.lat, r.lng], {
          radius: 5,
          color: "#38bdf8",
          fillColor: "#0ea5e9",
          fillOpacity: .8
        }).bindPopup(`<b>Encuesta:</b> ${r.survey_user_id}`);
        m.addTo(layerTotal);
        markers.push([r.lat, r.lng]);
      }
    });

    // Viviendas
    (payload.viviendas_geo || []).forEach(r => {
      if(r.lat && r.lng){
        let m = L.marker([r.lat, r.lng], {icon: houseIcon})
          .bindPopup(`<b>Vivienda:</b> ${r.vivienda}`);
        m.addTo(layerViviendas);
        markers.push([r.lat, r.lng]);
      }
    });

    // Sectores
    let sectoresDict = {};
    (payload.sectores_geo || []).forEach(r => {
      if(!sectoresDict[r.sector]) sectoresDict[r.sector] = [];
      sectoresDict[r.sector].push([r.lat, r.lng]);
    });
    for(const [sector, pts] of Object.entries(sectoresDict)){
      if(pts.length >= 3){
        L.polygon(pts, {
          color:"#f97316",
          weight:2,
          fillColor:"#facc15",
          fillOpacity:.3
        }).addTo(layerSectores);
      }
      pts.forEach(p=>{
        L.circleMarker(p, {
          radius: 4,
          color: "#f59e0b",
          fillColor: "#fbbf24",
          fillOpacity:.9
        }).bindPopup(`<b>Sector:</b> ${sector}`).addTo(layerSectores);
        markers.push(p);
      });
    }

    // Ajustar zoom solo primera vez
   if(firstFit){
    zoomToCluster(markers);
    firstFit = false;
  }

    lastMarkers = markers;
  }

  // === BOT√ìN "RECENTRAR" ===
  const recenterBtn = L.control({position:'topleft'});
  recenterBtn.onAdd = function(){
    let div = L.DomUtil.create('div','');
    div.innerHTML = `
      <button id="btn-recenter" 
        class="bg-indigo-600 hover:bg-indigo-700 text-white px-3 py-1 rounded-lg shadow-lg">
        üîç Recentrar
      </button>`;
    return div;
  };
  recenterBtn.addTo(map);

  document.addEventListener("click", e=>{
    if(e.target && e.target.id==="btn-recenter" && lastMarkers.length>0){
      zoomToCluster(lastMarkers);

    }
  });

  // === REFRESCAR DATOS ===
  renderCharts();
  async function refresh(){ try{ updateUI(await fetchData()); } catch(e){ console.error(e); } }
  refresh();
  setInterval(refresh, 10000);

  // === FUNCI√ìN PARA HACER ZOOM A LA ZONA PRINCIPAL ===
function zoomToCluster(markers){
  if(markers.length === 0){
    map.setView([4.65, -74.1], 8); // Bogot√° por defecto
    return;
  }

  // Calcular centro promedio
  let latSum = 0, lngSum = 0;
  markers.forEach(p => { latSum += p[0]; lngSum += p[1]; });
  let center = [latSum/markers.length, lngSum/markers.length];

  // Calcular dispersi√≥n aproximada
  let maxDist = 0;
  markers.forEach(p => {
    let dLat = p[0] - center[0];
    let dLng = p[1] - center[1];
    let dist = Math.sqrt(dLat*dLat + dLng*dLng);
    if(dist > maxDist) maxDist = dist;
  });

  // Ajustar zoom en funci√≥n de la dispersi√≥n
  let zoom = 14; // por defecto cercano
  if(maxDist > 0.5) zoom = 8;   // muy disperso (ej: varios municipios)
  else if(maxDist > 0.1) zoom = 11; // moderado
  else if(maxDist > 0.05) zoom = 13;

  map.setView(center, zoom);
}